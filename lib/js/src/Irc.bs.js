// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Net = require("net");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");

var Conn = {};

var nick = {
  contents: ""
};

var hostMask = {
  contents: ""
};

var maxLineLength = {
  contents: 0
};

var requestedDisconnect = {
  contents: false
};

var receiveBuffer = {
  contents: []
};

function updateMaxLineLength(param) {
  maxLineLength.contents = (497 - nick.contents.length | 0) - hostMask.contents.length | 0;
  
}

function send(conn, command) {
  var args = command.slice();
  var patternA = /\s/;
  var patternB = /^:/;
  var len = args.length;
  if (Belt_Option.isSome(Caml_option.null_to_opt(Caml_array.get(args, len - 1 | 0).match(patternA))) === true || Belt_Option.isSome(Caml_option.null_to_opt(Caml_array.get(args, len - 1 | 0).match(patternB))) === true || Caml_array.get(args, len - 1 | 0) === "") {
    Caml_array.set(args, len - 1 | 0, ":" + Caml_array.get(args, len - 1 | 0));
  }
  if (requestedDisconnect.contents === false) {
    conn.write(args.join(" ") + "\r\n");
    return ;
  }
  
}

function newClient(server, portOpt, password, nickname) {
  var port = portOpt !== undefined ? portOpt : 6667;
  return {
          server: server,
          port: port,
          nickname: nickname,
          password: password !== undefined ? password : "",
          username: "Rescript IRC Bot",
          realname: "Rescript IRC Bot",
          nickPass: "",
          usermode: "+RB -x",
          channels: [],
          isSasl: false,
          webIrc: undefined,
          retryCount: 10,
          retryDelay: 5
        };
}

function connectListener(conn, opt) {
  if (Belt_Option.isSome(opt.webIrc) === true) {
    var args = Belt_Option.getExn(opt.webIrc);
    send(conn, [
          "WEBIRC",
          args.pass,
          opt.username,
          args.host,
          args.ip
        ]);
  }
  if (opt.isSasl === true) {
    send(conn, [
          "CAP REQ",
          "sasl"
        ]);
  } else {
    send(conn, [
          "PASS",
          opt.password
        ]);
  }
  send(conn, [
        "NICK",
        opt.nickname
      ]);
  nick.contents = opt.nickname;
  updateMaxLineLength(undefined);
  return send(conn, [
              "USER",
              opt.username,
              String(8),
              "*",
              opt.realname
            ]);
}

function connect(opt, retry) {
  var conn = Net.createConnection(opt.port, opt.server);
  conn.setTimeout(0);
  conn.setEncoding("utf8");
  conn.addListener("data", (function (chunk) {
          receiveBuffer.contents.push(chunk);
          var lines = receiveBuffer.contents.toString().split(new RegExp("\r\n|\r|\n")).map(Belt_Option.getExn);
          if (Belt_Option.getExn(Caml_option.undefined_to_opt(lines.pop())) === "") {
            receiveBuffer.contents = [];
            lines.forEach(function (line) {
                  
                });
            return ;
          }
          
        }));
  conn.addListener("close", (function (param) {
          if (requestedDisconnect.contents === false && retry < opt.retryCount) {
            setTimeout((function (param) {
                    connect(opt, retry + 1 | 0);
                    
                  }), opt.retryDelay);
            return ;
          }
          
        }));
  conn.addListener("error", (function (exception_) {
          console.log(exception_);
          
        }));
  return conn;
}

function disconnect(conn, msg) {
  if (conn.readyState === "open") {
    send(conn, [
          "QUIT",
          msg
        ]);
  }
  requestedDisconnect.contents = true;
  conn.end();
  
}

function end(conn) {
  conn.destroy();
  
}

function join(conn, opt, channel) {
  var channels = " ".split(channel);
  Belt_Array.map(channels, (function (x) {
          send(conn, [
                "JOIN",
                x
              ]);
          if (opt.channels.indexOf(x) === -1) {
            opt.channels.push(x);
            return ;
          }
          
        }));
  
}

function part(conn, opt, channel, msg, param) {
  if (msg !== undefined) {
    send(conn, [
          "PART",
          channel,
          msg
        ]);
  } else {
    send(conn, [
          "PART",
          channel
        ]);
  }
  if (opt.channels.indexOf(channel) !== -1) {
    opt.channels.splice(opt.channels.indexOf(channel), 1);
    return ;
  }
  
}

function whois(conn, nickname) {
  return send(conn, [
              "WHOIS",
              nickname
            ]);
}

var Client = {
  nick: nick,
  hostMask: hostMask,
  maxLineLength: maxLineLength,
  requestedDisconnect: requestedDisconnect,
  receiveBuffer: receiveBuffer,
  updateMaxLineLength: updateMaxLineLength,
  send: send,
  newClient: newClient,
  connectListener: connectListener,
  connect: connect,
  disconnect: disconnect,
  end: end,
  join: join,
  part: part,
  whois: whois
};

exports.Conn = Conn;
exports.Client = Client;
/* net Not a pure module */
